## 트랜잭션의 범위 및 내부 로직 융합에 따른 문제점 분석
https://www.notion.so/9681f73d3d9e4522b096c2e6def9fe71?pvs=4

## 콘서트 예약 시스템에서의 Query 분석 및 DB Index 설계
https://www.notion.so/query-DB-Index-792b57fb40484c0487a4936c9c205a94?pvs=4

## 대기열 시스템 분석
https://www.notion.so/c1467e1f9c8b41dc9b15f5a180a0f0c7?pvs=4

## 동시성 문제와 극복 주차 과제 요약
- 아래의 동시성 제어 분석에 동시성 관련하여 고민한 것들을 정리하고, 구현 로직에 대한 근거를 서술해두었습니다.
- 통합 테스트를 포함한 모든 테스트 코드는 test 디렉토리 내에 모두 작성해두었습니다.
- 테스트의 모든 케이스는 main 브랜치의 ci 결과를 통해 각 항목 별로 테스트 종류와 성공 여부를 확인할 수 있습니다.
 ![image](https://github.com/dlwlsh92/concert-reservation/assets/102504924/8b3abba6-74ca-4d92-809f-6ad2005b1ace)


## 동시성 제어 분석

### Redis 사용 근거

- 대기열이 필요한 근본적인 이유
    - 많은 수의 인원이 동시에 예약에 접근해서 한정된 자원(콘서트 좌석)에 대한 과도한 경합과 리소스 (cpu, db) 부족으로 인해 발생하는 문제를 해결하고자 하는 것
- Database만으로 구현했을 때의 한계점
    - 콘서트 예약 시스템에서 주요 요구사항은 아래와 같음.
        - 유저는 토큰을 이용해 대기열 검증을 통과해야 예약과 관련된 기능을 사용할 수 있고, 토큰은 대기 순서와 같은 정보를 포함한다.
        - 다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없어야 한다.
    - 데이터베이스만으로 토큰을 관리한다면?
        - 클라이언트에서 유저들이 자신의 대기열 상태를 확인하기 위해 폴링을 통해 계속 토큰 상태를 확인하는 요청을 한다고 가정하면 결국 접근 가능한 상태를 조회하기 위해 데이터베이스에 접근할 수 밖에 없다. 즉, 데이터베이스의 한정된 커넥션 수의 부족을 해결할 수 없음.
        - 시간이 지날수록 토큰은 계속 쌓이게 되고, 각 유저들이 요청할 때마다 자신의 순서를 조회하기 위해서는 전체 토큰을 스캔하는데 비용이 점점 커진다. 그리고, 인덱스를 걸어놓는다고 해도 유저가 많이 몰릴 때는 토큰을 생성하는 요청이 굉장히 많아질텐데 즉, 쓰기 요청 또한 굉장히 많을 것으로 판단되어 인덱스를 효율적으로 유지하는 것이 복잡할 것으로 판단됨.
            - 효율적으로 인덱스를 관리할 수 있는 방안에 대해 찾아볼 것
    - 토큰 관리에 redis를 사용하기로 한 이유
        - 대기열 시스템에서 중요한 사항 중 하나인많은 유저들이 자신의 상태를 조회하는 요청을 얼마나 빨리 처리할 수 있느냐의 관점에서 데이터베이스에 접근하기 전에 효율적으로 요청을 처리할 수 있음.
        - 토큰은 단순히 예약 관련 기능들에 접근할 수 있는 권한을 확인하는 용도이기 때문에 휘발성이 존재하는 redis를 사용하는 것에 대한 부담이 적을 것으로 판단함. (만일 필요하다면 database에 저장할 수 있음)
        - 토큰이 계속 쌓이게 되면 리소스 낭비를 방지하기 위해 정기적으로 만료된 토큰을 삭제해주는 절차를 따로 해야 하지만 redis에서 ttl을 설정할 수 있기 때문에 효율적이라 판단함.
            - 근데 redis에서는 어떻게 이것을 가능하게 하는 걸까 리소스를 많이 소요하진 않을까에 대해 고민을 해보면 좋을 것 같음.

### Point 충전/사용

- 현재 구현 방식 (낙관적 락)
    - 동일한 계정의 유저가 동시에 포인트를 사용 및 충전하는 행위는 거의 없을 것으로 판단하여, 즉, 동시 트랜잭션으로 인한 충돌은 거의 발생하지 않을 것으로 예상하여 version 필드를 사용한 낙관적 락으로 코드를 작성함.
    - 유닛 테스트 항목
        - 포인트 정보가 없을 경우 404 에러를 반환한다.
        - 포인트를 정상적으로 추가한다.
        - 포인트를 정상적으로 차감한다.
        - 포인트 차감 시 잔액이 부족할 경우 402 에러를 반환한다.
        - 포인트를 충전하는 경우 충전된 포인트를 반환한다.
        - 포인트를 차감하는 경우 차감된 포인트를 반환한다.
        - 포인트를 차감 시 차감할 포인트가 현재 포인트보다 큰 경우 차감에 실패한다.
    - 통합 테스트 항목
        - 포인트 충전 및 차감하는 요청들을 동시에 실행한 후, 성공한 요청들에 대한 포인트 연산의 합계가 database의 point 합계와 동일한지 확인함.

- 현재 동시성 제어 방식에 대한 근거 및 생각하는 장/단점
    - 근거
        - 동일한 계정의 유저가 동시에 포인트를 사용 및 충전하는 행위는 거의 없을 것으로 판단하여, 즉, 동시 트랜잭션으로 인한 충돌은 거의 발생하지 않을 것으로 예상함.
        - 현재 로직 상 포인트를 충전하고, 사용하는 행위는 비교적 간단한 로직임
            - 포인트를 사용할 때 조차 현재는 결제하고자 하는 예약이 유효한지 체크하는 로직밖에 존재하지 않는다. 따라서, 데이터 무결성을 유지하는 측면에서 만에 하나 트랜잭션 충돌로 인해 실패한다고 하더라도 롤백에 필요한 로직이 필요 없음.
    - 장점
        - 해당 테이블 행에 lock을 거는 행위가 없기 때문에 비관적 락과 비교하여 리소스를 덜 사용하고, 포인트를 조회하는데 있어 병목이 존재하지 않음.
    - 단점
        - 만일 동시 트랜잭션으로 인한 충돌로 인해 충전이나 사용 요청이 실패할 경우 유저에게 좋지 않은 경험을 줄 수 있음.
        - point는 돈과 직결된 사항이기 때문에 데이터 무결성이나 트랜잭션의 신뢰성 측면에서는 비관적 락과 같은 보수적인 방식이 더 적합할 수 있음.

- 결론
    - 현재는 포인트를 충전하거나 사용하는 로직이 매우 간단하기 때문에 현재 요구사항 기준으로는 굳이 비관적 락을 구현해야 할 이유를 마땅히 찾지 못했기 때문에 낙관적 락으로 구현한다. 다만, 동일한 유저에 대해 포인트 관련 요청이 동시에 들어올 것으로는 거의 생각되지 않기 때문에 retry를 해야 할 경우는 없을 것으로 판단되지만 트랜잭션 충돌로 인한 실패 경험은 유저에게 좋지 않을 것으로 판단되어 적당한 횟수에 대한 retry를 추가하여 보완하기로 결정함.
        - retry 하더라도 포인트를 충전 및 감소시키는 행위 자체는 매우 빠르게 실행할 수 있는 간단한 로직이기 때문에 충분하다고 판단됨.
    - 만일, 비즈니스 요구 사항이 더욱 복잡해져서 포인트에 대한 접근 경로가 많아져 충돌 확률이 높아진다거나 로직이 더욱 복잡해져서 트랜잭션 충돌로 인한 롤백 오버헤드가 커지는 경우 비관적 락을 고려할 수 있을 것 같다고 판단함.

### 좌석 선점

- 각 좌석당 가용 여부는 사용할 수 있거나 없거나 둘 중의 하나이다.
- 여러 유저가 동일한 좌석에 대한 예약 요청을 많이 할 것으로 판단하여 즉, 동시 트랜잭션에 의한 충돌이 많을 것으로 판단하여 비관적 락으로 좌석 선점에 대한 로직을 작성함.
- Seat 테이블 구조
    
    ```sql
    model Seat {
      id              Int       @id @default(autoincrement())
      concertEventId  Int
      seatNumber      Int
      expirationDate     DateTime
      isPaid         Boolean   @default(false)
      price           Int
      concertEvent    ConcertEvent @relation(fields: [concertEventId], references: [id])
      reservations    Reservation[]
    }
    ```
    
- 선점할 수 있는지에 대한 여부
    - isPaid가 false이고, expirationDate가 현 시점보다 이전인 경우를 좌석 선점이 가능한 상태라고 정의한다.
        - 좌석 선점에 성공했을 경우, expirationDate를 현 시점에서 5분을 더한 값으로 지정함.
        - 해당 좌석에 대한 결제가 완료되었을 경우, isPaid를 true로 update 한다.
    - 위의 항목에 따라 조건은 아래와 같이 구분된다.
        - isPaid가 false이고, expirationDate가 현 시점보다 이후인 경우, 결제가 완료되진 않았지만 누군가에 의해 좌석이 선점된 것으로 판단함.
        - isPaid가 true이고, expirationDate가 현 시점보다 이전인 경우, 누군가에 의해 좌석이 결제되어 확정된 것으로 판단한다.
- 유닛 테스트 항목 (좌석 예약에 관한 유닛테스트만 포함)
    - 예약 가능한 콘서트 좌석은 만료 시각이 현재보다 이전이고, 결제가 완료되지 않은 좌석이다.
    - 결제가 완료되지 않았더라도 좌석의 만료 시각이 현재보다 이후인 경우 다른 사람에 의해 예약되었다고 판단하여 예약이 불가능하다.
    - 만료 시각이 현재보다 이전이지만 결제가 완료된 좌석은 예약이 불가능하다.
- 통합 테스트 항목
    - 여러 유저가 동일한 좌석에 대한 예약 요청을 동시에 실행하고, 응답 중에 좌석 선점에 성공한 응답이 하나인지를 판별함.

<aside>
💡 좌석 점유에 동시성 제어 고민 사항

</aside>

- 비관적 락을 구현함으로 인해 생각하는 장단점
    - 장점
        - 좌석을 점유하는 과정 자체가 짧기 때문에 lock에 의한 영향이 크지 않음.
        - 동일한 좌석에 대한 동시 점유 요청이 많기 때문에 트랜잭션 충돌로 인한 실패를 방지할 수 있음.
    - 단점
        - 현 테이블 구조하에서 좌석의 비관적 락에 의해 유저의 예약 가능한 좌석에 대한 조회 요청에 대한 병목이 발생할 수 있음.
        - 좌석을 점유할 수 있는 유저는 하나뿐이라는 측면에서 데이터 무결성을 유지할 수 있음
        - 잠금을 획득하기 위한 경합으로 인한 리소스 사용

<aside>
💡 대안

</aside>

- 낙관적 락으로 구현
    - 생각하는 근거
        - 최대 정원이 존재하는 수강 등록과 같은 케이스는 낙관적 락으로 구현했을 경우 정원의 여유가 있음에도 불구하고, 트랜잭션 충돌로 인해 등록이 불가능할 수 있기 때문에 충돌로 인한 실패의 경우 retry를 해야할 수 있다 → 비관적 락이 더 적합하다고 판단함.
        - 하지만 좌석의 점유는 하나의 좌석에 한 유저만 예약을 할 수 있기 때문에 boolean이고, 예약을 하는데 있어 추가적인 확인 로직이 필요한 것이 아니고, 좌석이 예약할 수 있는 상태이기만 하면 예약을 할 수 있기 때문에 충돌이 발생했을 때, 이미 누군가 좌석을 점유했다고 판단하여 retry를 시키지 않아도 되지 않을까라는 생각
            - 좌석을 예약할 수 있는지에 대한 여부를 판단할 때, 추가적인 로직이 필요하지 않음. 만약에 추가적인 확인 로직이 있다면 현재 점유하고 있는 인원이 추가 로직에 의해 실패했을 경우를 고려할 수 있지만 현 시점에서는 그런 조건은 존재하지 않음. 즉, 예약 가능하면 무조건 할 수 있음.
    - 낙관적 락으로 인해 얻을 수 있는 이점
        - 예약 가능한 좌석을 조회하는 데 있어 테이블 락으로 인한 병목이 발생하지 않음.
        - 락을 획득하기 위한 경합에 드는 리소스가 없음.

- 좌석 점유에 대한 정보를 읽기용과 쓰기용으로 분리함 + 비관적 락.
    - 좌석 점유를 판단하는 field들을 따로 분리하여 lock이 적용되는 범위를 제한함.
    - 예를 들어 아래와 같이 구분함.
        
        ```sql
        // 예약할 수 있는 좌석의 정보를 조회할 때는 Seat의 expirationDate와 isPaid를 기준으로
        // 판단하여 반환함.
        model Seat {
          id              Int       @id @default(autoincrement())
          concertEventId  Int
          seatNumber      Int
          expirationDate     DateTime
          isPaid         Boolean   @default(false)
          price           Int
        }
        
        // 실제로 좌석 예약에 대한 요청은 아래의 테이블을 통해 진행하고, 좌석 점유가 완료되면
        // Seat의 expirationDate와 isPaid를 업데이트 해줌 (최종적 일관성 유지)
        model SeatStatus {
        	expirationDate DateTime
        	isPaid Boolean
        }
        ```
        
    - 장점
        - 락에 의해 조회 성능이 떨어지는 것을 방지할 수 있음.
    - 단점
        - Seat의 expirationDate와 isPaid는 완전 최신의 상태는 아니기 때문에 유저 입장에서는 예약 가능한 상태를 보고 요청했음에도 불구하고, 이미 선점되어 예약할 수 없는 좋지 않은 경험을 할 수 있음.
    
    <aside>
    💡 결론
    
    </aside>
    
    - 현재 좌석 예약의 동시성 제어를 위해 필요한 비관적 락으로 인해 예약 가능한 좌석의 조회에 병목이 생기는 것이다. 이를 개선하기 위한 방법으로는 아래의 두 가지를 생각했다.
        - 낙관적 락으로 구현 변경
        - 좌석의 점유 여부를 판단할 수 있는 field들을 다른 테이블로 분리하여 write와 read 용을 구분한다. 따라서, 점유할 수 있는 좌석의 상태가 완전한 실시간성을 보장하진 않지만 lock과 관계 없이 조회가 가능하다.
    - 결정 사항
        - 낙관적 락으로 구현을 변경함
    - 근거
        - 동일한 좌석에 대한 동시 예약 요청은 굉장히 많기 때문에 트랜잭션 충돌은 많이 일어나겠지만 좌석의 점유 특성상 좌석이 예약 가능한 상태이기만 하면 다른 로직이 필요 없이 좌석을 점유할 수 있기 때문에 누군가에 의해 업데이트 되었다는 것은 트랜잭션 충돌과 관계없이 이미 예약된 좌석이라는 결론을 내릴 수 있다.
            - 좌석 예약은 예약 가능한 상태이기만 하면 다른 조건 없이 예약할 수 있다. 따라서, 누군가에 의해 업데이트 되었다면 이미 선점되었다고 판단할 수 있어 트랜잭션 충돌이 있어도 retry 할 필요가 없을 것으로 판단함.
            - 예를 들어, 수강 등록과 같이 정원이 정해져 있는 경우는 등록할 수 있는 정원의 여분이 있음에도 불구하고, 트랜잭션 충돌로 인해 실패할 경우 다시 시도를 해야 하고, 그만큼 충돌이 많아 부적합할 수 있지만 좌석 점유는 했냐 안했냐 뿐이기 때문에 적합하다고 판단함.
        - 낙관적 락으로 구현함으로써 예약 가능한 좌석을 조회할 때도 업데이트를 기다릴 필요 없이 가능하기 때문에 병목이 개선될 것으로 판단함.

## 과제 요약

- 콘서트 티켓팅 서비스를 구현합니다.
- 유저들이 효과적으로 예약 서비스를 이용할 수 있게 대기열 시스템을 구축하고, 가용 가능한 인원들만 예약 서비스를 이용할 수 있게 합니다.
- 동일한 좌석에 접근하는 유저의 동시성을 고려하고, 이미 선점한 좌석에 대해 다른 유저들이 접근할 수 없도록 합니다.
- ERD는 마지막에 추가해두었습니다.

## 브랜치 관리 전략
- 초기 프로젝트이고, 브랜치 전략에 대한 자세한 경험이 없어, 유지 브랜치는 main만 두고, 개발 단계에 따라 feature, staging으로 구성하여 관리
- 기능 단위로 feature 브랜치를 생성하여 개발하고, 하위 브랜치를 필요한 경우 허용하지만 브랜치간의 의존성이 배포 과정에 비효율을 가져다 줄 수 있어 최대한 작은 단위의 feature 단위로 작업하여 staging에 병합할 수 있도록 함.
- commit이 많아질수록 코드리뷰에 어려움이 생기기 때문에 의미 없는 commit들은 rebase로 통합하여 commit 단위로 코드 리뷰를 할 수 있도록 함.
- staging 및 main으로 PR 요청 시 테스트를 비롯한 CI 도구를 통해 문제를 조기에 파악할 수 있도록 함.

### 브랜치 구성
- feature: 개발 환경 브랜치 (보조 브랜치)
  - 기능 단위로 개발하는 브랜치이고, 개발 완료 후 staging으로 merge
  - main에서 branch 생성하여 개발
- staging: feature 브랜치가 병합되는 통합 테스트 브랜치 (보조 브랜치)
  - QA를 비롯한 통합 테스트
  - 모든 테스트가 종료되면 main으로 merge한다. merge에서 발생하는 conflict는 모두 staging에서 main을 merge하여 해결한다.
  - 하위 브랜치는 생성하지 않음
- main: 배포 가능한 형태를 가진 브랜치 (유지 브랜치)

  
## Swagger

- test code는 src/test 폴더에 모두 작성해두었습니다!

### 좌석 결제 요청
![image](https://github.com/dlwlsh92/concert-reservation/assets/102504924/a9b914d4-da4f-4fc3-b2c8-aa5d90928169)

### 포인트 조회
![image](https://github.com/dlwlsh92/concert-reservation/assets/102504924/9bd55dd4-4bd3-4c87-b6e4-e5bdf51d63ac)

### 포인트 충전
![image](https://github.com/dlwlsh92/concert-reservation/assets/102504924/235d7f7d-cc6f-4f57-9ade-2485428afac4)

### 대기열 토큰 발급 요청
![image](https://github.com/dlwlsh92/concert-reservation/assets/102504924/3c40e95e-b95b-4ecf-bb17-332acbed754e)

### 대기열 토큰 검증
![image](https://github.com/dlwlsh92/concert-reservation/assets/102504924/fc1ed57a-3f0e-4116-b928-d1e46d6ed5fd)

### 예약 가능한 콘서트 날짜 조회(대기열 토큰 검증 이후 요청 가능함)
![image](https://github.com/dlwlsh92/concert-reservation/assets/102504924/74becd0e-7126-4b1c-a2ec-07d9b948e090)

### 예약 가능한 좌석 조회(대기열 토큰 검증 이후 요청 가능함)
![image](https://github.com/dlwlsh92/concert-reservation/assets/102504924/4cf74577-52d9-4b4f-82fe-bc59d2213afe)

### 좌석 예약 요청(대기열 토큰 검증 이후 요청 가능함)
![image](https://github.com/dlwlsh92/concert-reservation/assets/102504924/3e504813-9ce4-4aba-9fc1-d0604950a8ab)


## 주요 구현 내용

- 콘서트 예약 가능한 날짜/좌석 조회, 좌석 예약을 하기 위해서는 토큰 검증을 거쳐야 합니다.
- 토큰 발급 시 예약 서비스를 이용할 수 있는 시각과 토큰 만료 시각을 함께 저장합니다.
- 예약 서비스로의 접근을 효과적으로 제어하기 위해 유저들을 사이클 별로 관리합니다.
    - 분당 예약을 처리할 수 있는 건수를 10개로 가정합니다
        - 시스템 성능과 같은 사항을 고려해야 할 것 같지만 관련 경험이 없어 일단 위의 숫자로 가정했습니다.
    - 한 사이클 당 예약 가능한 시간을 5분으로 설정하면 5분에 50개의 예약을 처리할 수 있다고 가정하여 한 사이클 당 50명씩 접근 가능하도록 하고, 초과했을 경우 다음 사이클에 배정시킵니다.
- 따라서, 유저는 토큰을 발급 받을 때, 대기열의 인원수를 통해 아래와 같이 서비스 이용 시작 시각과 만료 시각을 계산하여 토큰과 함께 정보를 저장합니다.
    - 서비스 이용 가능 시각: 요청 시각 + 대기열 인원 수 // 50 * 5분
    - 토큰 만료 시각: 서비스 이용 시각 + 5분
- 대기열 인원 수가 커질수록(사이클 번호가 커지기 때문에) 의미 없이 대기해야 하는 시간이 높아지기 때문에 대기열 인원 수를 갱신할 때, 마지막 토큰의 만료 시각에 대기열 인원 수를 초기화 할 수 있도록 합니다.
- 유저는 polling을 통해 자신의 토큰 정보를 조회하여 서비스를 이용할 수 있는 유효한 상태인지 확인하고, 유효할 경우 예약 가능 날짜 및 좌석 조회, 예약 요청을 할 수 있습니다.
    - 아직 이용 가능한 시각에 도달하지 못했을 경우 대기해야 하는 시간과 함께 클라이언트에게 반환합니다.
- 대기열 인원 수와 token 정보는 redis에서 관리하여 유저들의 많은 수의 polling 요청이 데이터베이스에 도달하기 전에 어플리케이션 레벨에서 처리할 수 있도록 할 생각입니다.
    - token과 같이 휘발성 데이터에 대해 빠른 속도로 처리해야 하는 것의 특성상 redis에 저장하는 것이 유효하다고 판단함.
    - token에는 예약 서비스 이용 가능 시각과 만료 시각을 같이 저장합니다. 따라서, 유저는 토큰을 조회해서 자신이 예약 서비스를 이용할 수 있는 상태인지 여부를 판단하게 됩니다.
- 포인트 충전 및 사용은 user 별 요청이 매우 잦게 올 것이라고 판단하지 않기 때문에 낙관적 락을 통해 구현할 생각입니다.
- 좌석에 대한 예약은 동일한 좌석으로의 요청이 다수 있을 것으로 판단되어 비관적 락으로 구현할 계획입니다.


## 주요 고려사항

- 서비스 이용 시작 시각의 계산에 기저가 되는 대기열 인원 수를 어떻게 효과적으로 관리할 수 있을 것인가?
    - redis에 count를 update 할때마다 마지막 토큰 만료 시각을 TTL로 설정하여 count가 초기화 될 수 있도록 한다.
    - 만료 시각을 unix timestamp으로 변환 후 key로 지정하고, 만료 시각 당 인원 수를 따로 추적하여 해당 시간이 지났을 경우 대기열 count에서 해당 숫자만큼 빼서 최대한 실제 count를 반영할 수 있도록 한다…?
- 임시 좌석 배정의 경우 가용 가능한 좌석이지만 누락되어 사용할 수 없는 좌석이 발생하지 않도록 어떻게 효과적으로 처리할 수 있을까?
    - ~~예약 성공 시 setTimeout을 사용하여 5분 후에도 reservation의 status가 completed가 아닌 경우 좌석을 가용 가능한 상태로 변경한다~~ → 서버가 재시작 하거나와 같은 경우로 인해 태스크가 누락될 가능성 존재
    - 주기적으로 reservation을 검사해서 만료된 경우 해당 좌석의 status를 가용 가능하도록 변경한다..?
- 좌석 별로 동시성 문제를 해결하기 위해서 해당 행의 업데이트를 제한해야 하는데 그와 동시에 좌석 별 예약 가능한지 여부를 확인하는 조회 요청도 많이 쏟아질 것으로 예상되는데 어떻게 병목을 없앨 수 있을까?
    - 최종적 일관성을 이용하여 seats 테이블에 seatStatus를 두고, seatStatus만을 가진 별도의 테이블을 생성하여 lock을 해당 테이블로 제한한다. 그리고, 좌석 배정이 되거나 취소되면 비동기로 seats 테이블의 status를 변경해주는 작업을 한다. 유저가 완전 최신의 좌석 정보를 알 수는 없지만 좌석 배정 시 해당 좌석이 사용 가능한지를 확인하기 때문에 문제는 없지 않을까?
        - 하지만 예약할 수 있다고 떠서 눌렀는데 정보 불일치로 예약을 할 수 없는 유저 경험이 많다면 위의 방법은 사용할 수 없을 것으로 보인다.
     
    
## 마일스톤

- 1주차
    - 요구사항 분석 및 sequence diagram 작성
    - api 명세 및 ERD 설계
    - Mock API 작성
- 2주차
    - domain 모델/로직 정의 및 단위 테스트
    - 토큰 검증 로직 구현 및 사이클 구현
    - 좌석 예약 구현
    - 결제 구현
    - 포인트 충전/조회 구현
    - 서비스 로직 테스트 코드 작성
- 3주차
    - 실제 시나리오 기반 통합 테스트 작성
    - 리팩토링
    - 추가 개선 사항 적용


## 시퀀스 다이어그램
1. 토큰 유효성 검증
   
   ```mermaid
   sequenceDiagram
    autonumber
    actor cl as Client
    participant Server
    participant Redis

    cl ->> Server: 토큰 유효성 검증 요청
    activate Server

    Server ->> Redis: 토큰 조회

    Redis -->> Server: 토큰 정보(대기열 정보)

    deactivate Server

    alt 토큰이 존재하지 않는 경우
        Server -->> cl: TokenNotFoundException
        cl ->> Server: 토큰 발급 요청
        Server -->> cl: 발급한 토큰 반환
    else 이용 시간 이전인 경우
        Server -->> cl: 대기중 및 대기시간 반환
    else 토큰이 만료된 경우
        Server -->> cl: TokenExpiredException
    end
   ```

2. 예약 서비스

   ```mermaid
       sequenceDiagram
        autonumber
        actor cl as Client
        participant Server
        
        note over cl, Server: 예약 가능한 날짜 조회
    
        cl ->> Server: 토큰 유효성 검증
        Server -->> cl: 유효한 토큰 응답
    
        note over Server: 토큰 유효성 검증 성공 가정, 실패 시 토큰 유효성 검증 flow에 따라 대기
    
        cl ->> Server: 예약 가능 날짜 조회
        Server -->> cl: 예약 가능한 날짜를 배열 형태로 반환하고, 없을 경우 빈 배열 반환
    
    
        note over cl, Server: 예약 가능한 좌석 조회
    
        cl ->> Server: 토큰 유효성 검증
        Server -->> cl: 유효한 토큰 응답
    
        note over Server: 토큰 유효성 검증 성공 가정, 실패 시 토큰 유효성 검증 flow에 따라 대기
    
        cl ->> Server: 예약 가능 좌석 조회
        Server -->> cl: 예약 가능한 좌석을 배열 형태로 반환하고, 없을 경우 빈 배열 반환
    
        note over cl, Server: 좌석 예약 요청
    
        cl ->> Server: 토큰 유효성 검증
        Server -->> cl: 유효한 토큰 응답
    
        note over Server: 토큰 유효성 검증 성공 가정, 실패 시 토큰 유효성 검증 flow에 따라 대기
    
        cl ->> Server: 좌석 예약 요청
        
        alt 좌석 예약이 가능한 경우
            Server -->> cl: true를 반환하고, 5분간 좌석 임시 배정
        else 이미 좌석이 선점된 경우
            Server -->> cl: AlreadyAssignedSeatsException
        end
   ```

3. 결제 요청

   ```mermaid
       sequenceDiagram
        autonumber
        actor cl as Client
        participant Server
        
        note over cl, Server: 잔액 조회
    
        cl ->> Server: 잔액 조회 요청
        Server -->> cl: 잔액 반환
    
        note over cl, Server: 잔액 충전
    
        cl ->> Server: 잔액 충전 요청
        Server -->> cl: 갱신된 잔액 반환
    
        note over cl, Server: 결제 요청
    
        cl ->> Server: 결제 요청
    
        alt 결제 성공
            note over Server: 예약 상태 및 좌석 상태 업데이트
            Server ->> cl: true 반환
        else 잔액 부족
            Server -->> cl: 잔액 부족 exception
        else 결제 유효 시간이 지난 경우
            Server -->> cl: 유효 시간 만료 exception
        else 이미 결제한 항목일 경우
            Server -->> cl: 이미 결제한 항목 exception
        else 존재하지 않는 예약인 경우
            Server -->> cl: 존재하지 않는 예약 exception
        end
   ```


## API 명세

1. 토큰 발급 요청, POST
    1. 경로: /reservations/token
    2. 요청 데이터:
        
        ```jsx
        {
            userId: number,
            concertId: number,
        }
        ```
        
    3. 응답 데이터: token

1. 토큰 유효성 검증 요청, GET
    1. 경로: /reservations/token/validation?reservationToken=Token
    2. 응답 데이터:
        
        ```jsx
        {
            status: 'avaliable' | 'pending'
            waitingTime: number | null
        }
        ```
        
    3. 예외 케이스
        1. 토큰이 존재하지 않는 경우
            - TokenNotFoundException 발생
        2. 이용 시간 이전인 경우
            - status: pending, watingTime: 대기시간 응답
        3. 토큰이 만료된 경우
            - TokenExpiredException 발생
2. 예약 가능 날짜 조회, GET
    1. 토큰 유효성 검증을 통과한 후에 요청 가능
    2. 경로: /reservations/:consertId/available-dates
    3. 응답 데이터:
        
        ```jsx
        {
            concertEventId: number,
            startDate: Date,
            maxSeatCapacity: number,
            currentSeatCount: number,
        }[]
        // 예약 가능한 날짜가 없는 경우 빈 배열을 반환함.
        ```
        

1. 예약 가능 좌석 조회, GET
    1. 토큰 유효성 검증을 통과한 후에 요청 가능
    2. 경로: /reservations/:concertEventId/available-seats
    3. 응답 데이터:
        
        ```jsx
        {
            seatsId: number;
            seatsNumber: number;
        }[];
        // 예약 가능한 좌석이 없는 경우 빈 배열을 반환함.
        ```
        
    

1. 좌석 예약 요청, POST
    1. 토큰 유효성 검증을 통과한 후에 요청 가능
    2. 경로: /reservations/seats/:seatsId/assign
    3. 요청 데이터:
        
        ```jsx
        {
            concertEventId: number;
        }
        ```
        
    4. 응답 데이터: boolean
    5. 예외 케이스
        1. 해당 좌석이 이미 선점된 경우 AlreadyAssignedSeatsException

1. 잔액 조회, GET
    1. 경로: /points/users/:userId
    2. 응답 데이터: number

1. 잔액 충전, POST
    1. 경로: /points/users/:userId/charge
    2. 요청 데이터:
        
        ```jsx
        {
            amount: number;
        }
        ```
        
    3. 응답 데이터: number

1. 결제, POST
    1. 경로: /payment/:reservationId
    2. 응답 데이터: boolean
    3. 예외 케이스:
        1. 결제 유효 시간이 지난 경우
        2. 잔액이 부족한 경우
        3. 이미 결제한 항목인 경우
        4. 존재하지 않는 항목인 경우


## ERD
![image](https://github.com/dlwlsh92/concert-reservation/assets/102504924/915136c9-f054-4b95-a310-28b8489c15c0)

